#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""# yamlfixer
Automates the fixing of problems reported by
[yamllint](https://github.com/adrienverge/yamllint) by parsing its
output.

This software automatically fixes some errors and warnings reported by
yamllint.

usage:

```
$ yamlfixer *.yml - thisfile.yaml
```

This will launch yamllint on each specified file name (`-` is _stdin_),
then parse its output and try to fix reported problems in that file.

If input is read from _stdin_, the corrected output will be sent to
_stdout_. Other files will be overwritten if needed.

Diagnostic information is sent to stderr in verbose or debug modes.

This command exits with `0` if all input files pass
[yamllint](https://github.com/adrienverge/yamllint) strict mode, else
`-1`.

**IMPORTANT:** Not all problems are fixable by _yamlfixer_. Due to the way
[yamllint](https://github.com/adrienverge/yamllint) works, it doesn't
currenlty report all faulty lines, _yamlfixer_ might even introduce
indentation problems under some circumstances. Use at your own risk,
you have been warned...

"""

import sys
import os
import subprocess

LINTERCOMMAND = "yamllint --format parsable --strict -"

FIX_PASSEDLINTER = 0
FIX_MODIFIED = 1
FIX_UNMODIFIED = 2
FIX_SKIPPED = 3
FIX_PERMERROR = 4

class FileFixer:
    """To hold file fixing logic."""
    def __init__(self, filename):
        """Initialize a file to fix."""
        self.filename = filename
        if filename == '-':
            self.absfilename = '<stdin>'
        else:
            self.absfilename = os.path.abspath(filename)
        self.loffset = self.coffset = 0
        self.shebang = ""
        self.incontents = None

    def load(self):
        """Loads the input file's contents."""
        if self.filename == '-':
            self.incontents = sys.stdin.read()
        else:
            try:
                with open(self.filename, 'r') as yamlfile:
                    self.incontents = yamlfile.read()
            except FileNotFoundError as msg:
                sys.stderr.write(f"{msg}\n")

    def dump(self, outcontents):
        """Dumps the new file's contents."""
        if outcontents != self.incontents:
            retcode = FIX_MODIFIED
        else:
            retcode = FIX_SKIPPED
        if self.filename == '-':
            sys.stdout.write(self.shebang + outcontents)
            sys.stdout.flush()
        elif retcode == FIX_MODIFIED: # Don't write unnecessarily
            try:
                with open(self.filename, 'w') as yamlfile:
                    yamlfile.write(self.shebang + outcontents)
            except PermissionError as msg:
                sys.stderr.write(f"{msg}\n")
                retcode = FIX_PERMERROR
        return retcode

    def lint(self):
        """Launches the linter on a file's contents.

           Returns the (linter's exitcode, linter's stdout) tuple.
        """
        linter = subprocess.run(LINTERCOMMAND,
                                shell=True,
                                capture_output=True,
                                text=True,
                                check=False,
                                input=self.incontents,
                                encoding='utf-8')
        return (linter.returncode, linter.stdout)

    def fixfile(self):
        """Fix a file's contents."""
        self.load()
        if (self.incontents is None) or self.incontents.startswith('$ANSIBLE_VAULT;'):
            return FIX_SKIPPED
        (ltexitcode, ltstdout) = self.lint()
        if not ltexitcode:
            return FIX_PASSEDLINTER
        return None # TODO

class YAMLFixer:
    """To hold files fixing logic."""
    def __init__(self, arguments):
        """Initialize the fixer for all files."""
        for mode in ('verbose', 'debug'):
            attribute = f"{mode}mode"
            option = f"--{mode}"
            if option in arguments:
                setattr(self, attribute, True)
                arguments.remove(option)
            else:
                setattr(self, attribute, False)
        self.filenames = arguments
        if not self.filenames:
            self.filenames.append("-") # Add fake input from stdin
        self.passed = self.modified = self.unmodified = self.skipped = self.permerrors = 0

    def info(self, message):
        """Output an informational message to stderr if verbose mode is active."""
        if self.verbosemode: # pylint: disable=no-member
            sys.stderr.write(f"{message}\n")

    def debug(self, message):
        """Output a debug message to stderr if debug mode is active."""
        if self.debugmode: # pylint: disable=no-member
            sys.stderr.write(f"DEBUG: {message}\n")

    def error(self, message): # pylint: disable=no-self-use
        """Output an error message to stderr."""
        sys.stderr.write(f"ERROR: {message}\n")

    def statistics(self):
        """Output some statistics."""
        self.info(f"Files to fix: {len(self.filenames)}")
        self.info(f"{self.passed} files passed yamllint strict mode")
        self.info(f"{self.modified} files were modified")
        self.info(f"{self.unmodified} files were left unmodified")
        self.info(f"{self.skipped} files were skipped")
        self.info(f"{self.permerrors} files were not writeable")

    def fixfiles(self):
        """Fix all files."""
        for filename in self.filenames:
            filetofix = FileFixer(filename)
            self.info(f"Fixing {filetofix.absfilename} ...")
            status = filetofix.fixfile()
            if status == FIX_PASSEDLINTER:
                self.debug(f"{filetofix.absfilename} passed linter's strict mode.")
                self.passed += 1
            elif status == FIX_MODIFIED:
                self.debug(f"{filetofix.absfilename} was modified.")
                self.modified += 1
            elif status == FIX_UNMODIFIED:
                self.debug(f"{filetofix.absfilename} was left unmodified.")
                self.unmodified += 1
            elif status == FIX_SKIPPED:
                # file was skipped (e.g. Ansible vault, or file not found
                self.debug(f"{filetofix.absfilename} was skipped.")
                self.skipped += 1
            elif status == FIX_PERMERROR:
                self.debug(f"{filetofix.absfilename} was not writeable.")
                self.permerrors += 1
            else:
                self.error(f"Unknown status {status} for {filetofix.absfilename}")

        self.statistics()
        if (self.passed + self.skipped) == len(self.filenames):
            return 0
        return -1

def oldfix(lines, offsets, position, message):
    """Tries to fix a yamllint problem."""
    (loffset, coffset) = offsets
    (linenum, colnum) = position
    sys.stderr.write(f"{position}/{offsets} => {message}\n")
    linenum += loffset - 1
    colnum += coffset - 1
    if message == 'missing document start "---" (document-start)':
        lines.insert(0, '---')
        loffset += 1
    elif message == 'truthy value should be one of [false, true] (truthy)':
        for trueval in ('on', 'yes', 'true'):
            if lines[linenum][colnum:].lower().startswith(trueval):
                lines[linenum] = lines[linenum][:colnum] + 'true' + lines[linenum][colnum+len(trueval):]
                coffset += len('true') - len(trueval)
                break
        for falseval in ('off', 'no', 'false'):
            if lines[linenum][colnum:].lower().startswith(falseval):
                lines[linenum] = lines[linenum][:colnum] + 'false' + lines[linenum][colnum+len(falseval):]
                coffset += len('false') - len(falseval)
                break
    elif message == 'too few spaces before comment (comments)':
        spaces = ' '
        if lines[linenum][colnum-1] != ' ':
            spaces += ' '
        lines[linenum] = lines[linenum][:colnum] + spaces + lines[linenum][colnum:]
        coffset += len(spaces)
    elif message == 'trailing spaces (trailing-spaces)':
        # No need to adjust coffset because we are at EOL by definition
        lines[linenum] = lines[linenum].rstrip()
    elif message.startswith('too many blank lines'):
        parts = message.split()
        blanklines = int(parts[4][1:])
        maxblanklines = int(parts[6].split(')')[0])
        nblines = blanklines - maxblanklines
        del lines[linenum:linenum + nblines]
        loffset -= nblines
    elif message == "syntax error: found character '\\t' that cannot start any token (syntax)":
        # TODO: We replace TAB with a single space for now
        # TODO: yamllint only reports the first one
        lines[linenum] = lines[linenum][:colnum] + ' ' + lines[linenum][colnum+1:]
    elif message in ('missing starting space in comment (comments)',
                     'too few spaces after comma (commas)'):
        lines[linenum] = lines[linenum][:colnum] + ' ' + lines[linenum][colnum:]
        coffset += 1
    elif message in ('too many spaces after colon (colons)',
                     'too many spaces after comma (commas)',
                     'too many spaces after hyphen (hyphens)'):
        pos = colnum
        while (pos > 0) and (lines[linenum][pos-1] == ' '):
            pos -= 1
        lines[linenum] = lines[linenum][:pos] + lines[linenum][colnum:]
        coffset -= (colnum - pos)
    elif message in ('too many spaces inside braces (braces)',
                     'too many spaces inside brackets (brackets)',
                     'too many spaces before comma (commas)',
                     'too many spaces before colon (colons)'):
        pos = colnum
        while (pos > 0) and (lines[linenum][pos-1] == ' '):
            pos -= 1
        lines[linenum] = lines[linenum][:pos] + lines[linenum][colnum+1:]
        coffset -= (colnum - pos + 1)
    elif message == 'comment not indented like content (comments-indentation)':
        if linenum > 0:
            indentation = len(lines[linenum-1]) - len(lines[linenum-1].lstrip())
            # If previous line is similarly indented then use indentation of next line
            if indentation == colnum:
                indentation = len(lines[linenum+1]) - len(lines[linenum+1].lstrip())
        else:
            indentation = len(lines[linenum+1]) - len(lines[linenum+1].lstrip())
        lines[linenum] = ' ' * indentation + lines[linenum].lstrip()
        coffset += (indentation - colnum)
    elif message.startswith('wrong indentation: expected'):
        # TODO: yamllint only reports the first faulty line in a block :-(
        # TODO: see https://github.com/adrienverge/yamllint/issues/427
        # TODO: we fix anyway, knowing that we may need to launch the command
        # TODO: several times to finally fix the problem.
        parts = message.split()
        expected = int(parts[3])
        found = int(parts[6])
        offset = expected - found
        if expected > found:
            lines[linenum] = (' ' * offset) + lines[linenum]
        else:
            # expected < found because we woudln't be there otherwise anyway
            lines[linenum] = lines[linenum][-offset:]
        coffset += offset
    elif message.startswith('line too long'):
        indentation = len(lines[linenum]) - len(lines[linenum].lstrip())
        lines.insert(linenum, ' ' * indentation + '# yamllint disable-line rule:line-length')
        loffset += 1

    return ((loffset, coffset), lines)

def oldmain(filenames):
    """Main function."""
    good = 0
    modified = 0
    for filename in filenames:
        if filename == '-':
            sys.stderr.write("Fixing -\n")
            oldcontents = sys.stdin.read()
        else:
            try:
                yamlfile = open(filename, 'r+')
            except FileNotFoundError as msg:
                sys.stderr.write(f"{msg}\n")
                continue
            else:
                sys.stderr.write(f"Fixing {os.path.abspath(filename)}\n")
                oldcontents = yamlfile.read()

        if oldcontents.startswith('$ANSIBLE_VAULT;'):
            sys.stderr.write(f"Skipped {filename} which seems to be an Ansible vault\n")
            continue

        yamllint = subprocess.run(f"yamllint --format parsable --strict -",
                                  shell=True,
                                  capture_output=True,
                                  text=True,
                                  check=False,
                                  input=oldcontents,
                                  encoding='utf-8')
        if not yamllint.returncode:
            sys.stderr.write(f"GOOD: {filename}\n")
            good += 1
            continue

        linestofix = {}
        for line in yamllint.stdout.splitlines():
            (_, linenumber, colnumber, message) = line.split(':', 3)
            (_, msg) = message.strip().split(' ', 1)
            colstofix = linestofix.setdefault(int(linenumber), {})
            coltofix = colstofix.setdefault(int(colnumber), [])
            coltofix.append(msg)

        if oldcontents.startswith('#!'):
            # We have to skip the shebang line and any problem reported for this line
            eolpos = oldcontents.find('\n') + 1
            shebang = oldcontents[:eolpos]
            oldcontents = oldcontents[eolpos:]
            try:
                del linestofix[1]
            except KeyError:
                pass
            loffset = -1
        else:
            shebang = ''
            loffset = 0

        lines = oldcontents.splitlines()
        for linenumber in sorted(linestofix.keys()):
            coffset = 0
            for colnumber in sorted(linestofix[linenumber].keys()):
                for problem in linestofix[linenumber][colnumber]:
                    ((loffset, coffset), lines) = oldfix(lines,
                                                         (loffset, coffset),
                                                         (linenumber, colnumber),
                                                         problem)

        newcontents = '\n'.join(lines) + '\n'
        if newcontents != oldcontents:
            sys.stderr.write(f"Fixed {filename}\n")
            if filename == '-':
                sys.stdout.write(shebang + newcontents)
                sys.stdout.flush()
            else:
                yamlfile.seek(0)
                yamlfile.write(shebang + newcontents)
                yamlfile.truncate()
                yamlfile.close()
            modified += 1
        else:
            sys.stderr.write(f"Skipped {filename}\n")
            if filename == '-':
                sys.stdout.write(shebang + newcontents)
                sys.stdout.flush()

    sys.stderr.write(f"Fixed {modified}/{len(filenames)-good} files\n")

def main(arguments):
    """Main function."""
    fixer = YAMLFixer(arguments)
    return fixer.fixfiles()

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
